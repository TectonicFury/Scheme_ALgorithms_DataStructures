(define (make-bst same? less? more?)
  (let ((bst (list '*bst*)))

    (define (make-node entry left-child right-child n)
      (list left-child entry right-child n)); the last field contains the size of the node

    (define (size tree-node)
      (if (null? tree-node)
          0
          (cadddr tree-node)))

    (define (lookup query-key)
      (define (iter-lookup sub-tree)
        (cond ((null? sub-tree) false)
              ((same? query-key (key (entry sub-tree))) (entry sub-tree))
              ((less? query-key (key (entry sub-tree))) (iter-lookup (left sub-tree)))
              (else (iter-lookup (right sub-tree)))))
      (iter-lookup (cdr bst)))

      (define (key entry)
        (car entry))
      (define (value entry)
        (cdr entry))
      (define (entry tree)
        (cadr tree))
      (define (make-entry key value)
        (cons key value))
      (define (left tree)
        (car tree))
      (define (right tree)
        (caddr tree))

      (define (insert new-key new-value)
        (define (iter-insert sub-tree)
          (cond ((null? sub-tree) (make-node (make-entry new-key new-value) '() '() 1))
                ((same? new-key (key (entry sub-tree)))
                  (change-entry! sub-tree new-value)
                  sub-tree);need to return the subtree
                ((less? new-key (key (entry sub-tree)))
                  (set-car! sub-tree (iter-insert (left sub-tree)))
                  (set-car! (cdddr sub-tree) (+ 1 (size (left sub-tree)) (size (right sub-tree))));resetting the sizes
                  sub-tree)
                (else
                  (set-car! (cdr (cdr sub-tree)) (iter-insert (right sub-tree)))
                  (set-car! (cdddr sub-tree) (+ 1 (size (left sub-tree)) (size (right sub-tree))))
                  sub-tree)))
        (set-cdr! bst (iter-insert (cdr bst)))
        (display (size (cdr bst))))

      (define (inorder)
          (define (iter sub-tree)
            (cond ((null? sub-tree) '())
                  (else
                    (let ((left-tree (iter (left sub-tree)))
                          (right-tree (iter (right sub-tree))))
                      (append left-tree (list (entry sub-tree)) right-tree)))))
          (iter (cdr bst)))

      (define (floor k);k is query-key
        (let ((tentative-floor 'not-found))
          (define (iter sub-tree)
            (cond ((null? sub-tree) tentative-floor)
                  ((or (less? (key (entry sub-tree)) k) (same? (key (entry sub-tree)) k))
                    (set! tentative-floor (entry sub-tree))
                    (iter (right sub-tree)))
                  (else (iter (left sub-tree)))))
          (iter (cdr bst))))

      (define (ceiling k)
        (let ((tentative-ceiling 'not-found))
          (define (iter sub-tree)
            (cond ((null? sub-tree) tentative-ceiling)
                  ((or (more? (key (entry sub-tree)) k) (same? (key (entry sub-tree)) k))
                    (set! tentative-ceiling (entry sub-tree))
                    (iter (left sub-tree)))
                  (else (iter (right sub-tree)))))
          (iter (cdr bst))))

      (define (min)
        (define iter (lambda (t)
                      (if (null? (left t))
                          (entry t)
                          (iter (left t)))))
        (iter (cdr bst)))

      (define (max)
        (define iter (lambda (t)
                      (if (null? (right t))
                          (entry t)
                          (iter (right t)))))
        (iter (cdr bst)))
    ; in shaa Allaah we'll come back to this::>> الحمد لله done!!! same night!!
    ; perhaps the node object will have to be sent messages for us to access n, the size of the sub-tree
    (define (select-key-with-rank n)
      (define (iter sub-tree nrk)
        (cond ((null? sub-tree) 'not-found)
              ((> (size (left sub-tree)) nrk) (iter (left sub-tree) nrk))
              ((= (size (left sub-tree)) nrk) (entry sub-tree))
              ((< (size (left sub-tree)) nrk) (iter (right sub-tree) (- nrk (size (left sub-tree)) 1)))))
      (iter (cdr bst) n))

    (define (rank-of-key query-key)
      (define (iter-rank sub-tree)
        (cond ((null? sub-tree) 'no-entry-with-said-key)
              ((same? query-key (key (entry sub-tree))) (size (left sub-tree)))
              ((less? query-key (key (entry sub-tree))) (iter-rank (left sub-tree)))
              (else (+ (size (left sub-tree)) 1 (iter-rank (right sub-tree))))))
      (iter-rank (cdr bst)))
      ; in shaa Allaah later
    (define (delete-min)
      (define (iter-del sub-tree)
        (cond ((null? (left sub-tree)) (right sub-tree))
              (else
                (set-car! sub-tree (iter-del (left sub-tree)))
                sub-tree)))
      (if (= 0 (size (cdr bst)))
          (error "Attempt to delete from empty BST")
          (set-cdr! bst (iter-del (cdr bst)))))

    (define (delete-max)
      (define (iter-del sub-tree)
        (cond ((null? (right sub-tree)) (left sub-tree))
              (else
                (set-car! (cdr (cdr sub-tree)) (iter-del (right sub-tree)))
                sub-tree)))
      (if (= 0 (size (cdr bst)))
          (error "Attempt to delete from empty BST")
          (set-cdr! bst (iter-del (cdr bst)))))

    (define (delete query-key)
      (define (min-node-helper st)
        (define iter (lambda (t)
                      (if (null? (left t))
                          t
                          (iter (left t))))) (iter st))
      (define (delete-min-node-helper st)
        (define iter (lambda (t)
                      (if (null? (left t))
                          (right t)
                          (begin
                            (set-car! t (iter (left t)))
                            t)))) (iter st))
      (define (iter-del sub-tree)
        (cond ((null? sub-tree) (error "Attempt to delete key not present" query-key))
              ((less? query-key (key (entry sub-tree)))
                (set-car! sub-tree (iter-del (left sub-tree)))
                sub-tree)
              ((more? query-key (key (entry sub-tree)))
                (set-car! (cdr (cdr sub-tree)) (iter-del (right sub-tree)))
                sub-tree)
              (else
                (cond ((and (null? (left sub-tree)) (null? (right sub-tree))) '())
                      ((null? (left sub-tree)) (right sub-tree))
                      ((null? (right sub-tree)) (left sub-tree))
                      (else
                        (let ((x (min-node-helper (right sub-tree)))
                              (t sub-tree))
                          (set-car! (cdr (cdr x)) (delete-min-node-helper (right t)))
                          (set-car! x (left t))
                          x))))))
    (iter-del (cdr bst)))

    (define (change-entry! node value)
      (set-cdr! (entry node) value))

    (define (dispatch message)
      (cond ((eq? message 'lookup) lookup)
            ((eq? message 'insert) insert)
            ((eq? message 'inorder) (inorder))
            ((eq? message 'floor) floor)
            ((eq? message 'ceiling) ceiling)
            ((eq? message 'select)
              select-key-with-rank)
            ((eq? message 'min) (min))
            ((eq? message 'del-min) (delete-min))
            ((eq? message 'max) (max))
            ((eq? message 'del-max) (delete-max))
            ((eq? message 'del) delete)
            ((eq? message 'rank-of-key) rank-of-key)
            (else (error "Wrong message to BST:" message))))
    dispatch))

(define (insert tree new-key new-value)
  ((tree 'insert) new-key new-value))
(define (lookup tree key)
  ((tree 'lookup) key))
(define (print-inorder tree)
  (tree 'inorder))
(define (floor tree key)
  ((tree 'floor) key))
(define (ceiling tree key)
  ((tree 'ceiling) key))
(define (min tree)
  (tree 'min))
(define (max tree)
  (tree 'max))
(define (select-rank tree rnk)
  ((tree 'select) rnk))
(define (rank-of-key tree key)
  ((tree 'rank-of-key) key))
(define (delete-min tree)
  (tree 'del-min))
(define (delete-max tree)
  (tree 'del-max))
(define (delete tree query-key)
  ((tree 'del) query-key))

; traditional implementation
(define (make-bst)
  (list '*bst*))

(define (make-node entry left-child right-child)
  (list left-child entry right-child))

;the entry has to have a key
(define (lookup tree query-key same? less?)
  (define (iter-lookup sub-tree)
    (cond ((null? sub-tree) false)
          ((same? query-key (key (entry sub-tree))) (entry sub-tree))
          ((less? query-key (key (entry sub-tree))) (iter-lookup (left sub-tree)))
          (else (iter-lookup (right sub-tree)))))
  (iter-lookup (cdr tree)))

;entry is a simple cons
(define (key entry)
  (car entry))
(define (value entry)
  (cdr entry))
(define (entry tree)
  (cadr tree))
(define (make-entry key value)
  (cons key value))
(define (left tree)
  (car tree))
(define (right tree)
  (caddr tree))

(define (insert new-key new-value tree less? more?)
  (define (iter-insert sub-tree)
    (cond ((null? sub-tree) (make-node (make-entry new-key new-value) '() '()))
          ((equal? new-key (key (entry sub-tree)))
            (change-entry! sub-tree new-value)
            sub-tree);need to return the subtree
          ((less? new-key (key (entry sub-tree)))
            (set-car! sub-tree (iter-insert (left sub-tree)))
            sub-tree)
          (else
            (set-car! (cdr (cdr sub-tree)) (iter-insert (right sub-tree)))
            sub-tree)))
  (set-cdr! tree (iter-insert (cdr tree))))

(define (inorder tree)
    (define (iter sub-tree)
      (cond ((null? sub-tree) '())
            (else
              (let ((left-tree (iter (left sub-tree)))
                    (right-tree (iter (right sub-tree))))
                (append left-tree (list (entry sub-tree)) right-tree)))))
    (iter (cdr tree)))

(define (floor k tree same? less?)
  (let ((tentative-floor 'not-found))
    (define (iter sub-tree)
      (cond ((null? sub-tree) tentative-floor)
            ((or (less? (key (entry sub-tree)) k) (same? (key (entry sub-tree)) k))
              (set! tentative-floor (entry sub-tree))
              (iter (right sub-tree)))
            (else (iter (left sub-tree)))))
    (iter (cdr tree))))

(define (ceiling k tree same? more?)
  (let ((tentative-ceiling 'not-found))
    (define (iter sub-tree)
      (cond ((null? sub-tree) tentative-ceiling)
            ((or (more? (key (entry sub-tree)) k) (same? (key (entry sub-tree)) k))
              (set! tentative-ceiling (entry sub-tree))
              (iter (left sub-tree)))
            (else (iter (right sub-tree)))))
    (iter (cdr tree))))

(define (min tree)
  (define iter (lambda (t)
                (if (null? (left t))
                    (entry t)
                    (iter (left t)))))
  (iter (cdr tree)))

(define (max tree)
  (define iter (lambda (t)
                (if (null? (right t))
                    (entry t)
                    (iter (right t)))))
  (iter (cdr tree)))

(define (change-entry! node value)
  (set-cdr! (entry node) value))
