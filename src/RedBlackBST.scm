; FOr later : Deletion and frequency counter 
(define (make-rbt same? less? more?)
  (let ((rbt (list '*rbt*)))

    (define (make-node entry left-child right-child color)
      (list left-child entry right-child color))

    (define (lookup query-key)
      (define (iter-lookup sub-tree)
        (cond ((null? sub-tree) false)
              ((same? query-key (key (entry sub-tree))) (entry sub-tree))
              ((less? query-key (key (entry sub-tree))) (iter-lookup (left sub-tree)))
              (else (iter-lookup (right sub-tree)))))
      (iter-lookup (cdr rbt)))

    (define (key entry)
      (car entry))
    (define (value entry)
      (cdr entry))
    (define (entry tree)
      (cadr tree))
    (define (make-entry key value)
      (cons key value))
    (define (left tree)
      (car tree))
    (define (right tree)
      (caddr tree))

    (define (isRed node)
      (if (null? node)
          false
          (eq? (cadddr node) 'RED)))
    (define (rotate-left node-h)
      (let ((x (right node-h)))
        (set-car! (cdr (cdr node-h)) (left x))
        (set-car! x node-h)
        (set-car! (cdr (cdr (cdr x))) (cadddr node-h))
        (set-car! (cdr (cdr (cdr node-h))) 'RED)
        x))
    (define (rotate-right node-h)
      (let ((x (left node-h)))
        (set-car! node-h (right x))
        (set-car! (cdr (cdr x)) node-h)
        (set-car! (cdr (cdr (cdr x))) (cadddr node-h))
        (set-car! (cdr (cdr (cdr node-h))) 'RED)
        x))
    (define (flip-colors node-h)
      (set-car! (cdddr node-h) 'RED)
      (set-car! (cdddr (left node-h)) 'BLACK)
      (set-car! (cdddr (right node-h)) 'BLACK))

    (define (insert new-key new-value)
      (define (iter-insert sub-tree)
        (cond ((null? sub-tree) (make-node (make-entry new-key new-value) '() '() 'RED))
              ((same? new-key (key (entry sub-tree)))
                (change-entry! sub-tree new-value)
                (if (and (isRed (right sub-tree)) (not (isRed (left sub-tree))))
                    (set! sub-tree (rotate-left sub-tree)))
                (if (and (isRed (left sub-tree)) (isRed (left (left sub-tree))))
                    (set! sub-tree (rotate-right sub-tree)))
                (if (and (isRed (left sub-tree)) (isRed (right sub-tree)))
                    (flip-colors sub-tree))
                sub-tree);need to return the subtree
              ((less? new-key (key (entry sub-tree)))
                (set-car! sub-tree (iter-insert (left sub-tree)))
                (if (and (isRed (right sub-tree)) (not (isRed (left sub-tree))))
                    (set! sub-tree (rotate-left sub-tree)))
                (if (and (isRed (left sub-tree)) (isRed (left (left sub-tree))))
                    (set! sub-tree (rotate-right sub-tree)))
                (if (and (isRed (left sub-tree)) (isRed (right sub-tree)))
                    (flip-colors sub-tree))
                ;(set-car! (cdddr sub-tree) (+ 1 (size (left sub-tree)) (size (right sub-tree))));resetting the sizes
                  sub-tree)
             (else
              (set-car! (cdr (cdr sub-tree)) (iter-insert (right sub-tree)))
              ;(set-car! (cdddr sub-tree) (+ 1 (size (left sub-tree)) (size (right sub-tree))))
              (if (and (isRed (right sub-tree)) (not (isRed (left sub-tree))))
                  (set! sub-tree (rotate-left sub-tree)))
              (if (and (isRed (left sub-tree)) (isRed (left (left sub-tree))))
                  (set! sub-tree (rotate-right sub-tree)))
              (if (and (isRed (left sub-tree)) (isRed (right sub-tree)))
                  (flip-colors sub-tree))
              sub-tree)))

          (set-cdr! rbt (iter-insert (cdr rbt)))
          (set-car! (cdddr (cdr rbt)) 'BLACK))
    ;
    (define (change-entry! node value)
      (set-cdr! (entry node) value))
    (define (dispatch message)
      (cond ((eq? message 'lookup) lookup)
            ((eq? message 'insert) insert)
            ((eq? message 'rbt) rbt)
            (else (error "Unknown message" message))))

    dispatch))
(define (lookup tree query-key)
  ((tree 'lookup) query-key))
(define (insert tree new-key new-value)
  ((tree 'insert) new-key new-value))
